<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
  <title>Science Works</title>
  <style>
    @font-face {
      font-family: 'Antique Olive';
      src: url('antique-olive-std/Antique-Olive-Std-Roman_3869.ttf') format('truetype');
      font-weight: normal;
      font-style: normal;
    }
    :root {
      --scale: 0.30;
    }
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      overflow: hidden;
      background: #fdfcfb;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
    }
    #scale-wrapper {
      width: calc(900px * var(--scale));
      height: calc(600px * var(--scale));
      position: relative;
      overflow: visible;
    }
    #container {
      position: absolute;
      top: 0;
      left: 0;
      width: 900px;
      height: 600px;
      background: #fdfcfb;
      transform: scale(var(--scale));
      transform-origin: top left;
    }
    canvas {
      display: block;
      width: 450px;
      height: 410px;
      position: absolute;
      top: calc(50% - 20px);
      left: calc(50% - 265px);
      transform: translate(-50%, -50%);
    }
    #canvas {
      z-index: 2;
    }
    #canvas-particles {
      pointer-events: none;
      z-index: 3;
    }
    #fallback {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-family: system-ui, sans-serif;
      color: #e83525;
      text-align: center;
    }
    .text-overlay {
      position: absolute;
      top: 50%;
      left: calc(50% + 210px);
      transform: translate(-50%, -50%);
      pointer-events: none;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #text-red {
      z-index: 1;
    }
    #text-bg {
      z-index: 4;
      overflow: visible;
      top: 0;
      left: 0;
      width: 900px;
      height: 600px;
      transform: none;
      justify-content: center;
      /* Offset text content 210px right of container center */
      padding-left: 420px;
      padding-right: 0;
    }
    .text-overlay span {
      display: block;
      font-family: 'Antique Olive', sans-serif;
      font-weight: normal;
      line-height: 0.85;
      text-transform: uppercase;
      white-space: nowrap;
      letter-spacing: -0.08em;
    }
    #text-red span {
      color: #e83525;
    }
    #text-bg span {
      color: #fdfcfb;
    }
    .text-overlay .line1 {
      font-size: 186.51px;
      transform-origin: 40% center;
      margin-right: 0.05em;
    }
    .text-overlay .line2 {
      font-size: 213.54px;
    }
  </style>
</head>
<body>
  <div id="scale-wrapper">
  <div id="container">
    <div id="text-red" class="text-overlay">
      <span class="line1">SCIENCE</span>
      <span class="line2">WORKS</span>
    </div>
    <canvas id="canvas"></canvas>
    <canvas id="canvas-particles"></canvas>
    <div id="text-bg" class="text-overlay">
      <span class="line1">SCIENCE</span>
      <span class="line2">WORKS</span>
    </div>
    <div id="fallback">
      <p>WebGL is not supported in your browser.</p>
    </div>
  </div>
  </div>

  <script id="vertex-shader" type="x-shader/x-vertex">
    attribute vec2 a_position;
    varying vec2 v_uv;

    void main() {
      v_uv = a_position * 0.5 + 0.5;
      gl_Position = vec4(a_position, 0.0, 1.0);
    }
  </script>

  <script id="fragment-shader" type="x-shader/x-fragment">
    precision highp float;

    varying vec2 v_uv;

    uniform vec2 u_resolution;
    uniform vec2 u_blobs[8];
    uniform float u_radii[8];
    uniform int u_blobCount;

    const vec3 BLOB_COLOR = vec3(0.910, 0.208, 0.145);

    void main() {
      vec2 uv = v_uv;
      float aspect = u_resolution.x / u_resolution.y;
      uv.x *= aspect;

      float field = 0.0;

      for (int i = 0; i < 8; i++) {
        if (i >= u_blobCount) break;

        vec2 blobPos = u_blobs[i];
        blobPos.x *= aspect;

        float r = u_radii[i];
        float dx = uv.x - blobPos.x;
        float dy = uv.y - blobPos.y;
        float dist2 = dx * dx + dy * dy;

        field += (r * r) / dist2;
      }

      float threshold = 1.0;
      float edge = smoothstep(threshold - 0.02, threshold + 0.02, field);

      // Output blob color with alpha based on edge
      // Transparent where no blob, opaque where blob
      gl_FragColor = vec4(BLOB_COLOR, edge);
    }
  </script>

  <script>
    const CONFIG = {
      BLOB_COUNT: 8,
      DAMPING: 0.9955,
      PERTURBATION_STRENGTH: 0.00018,
      REPULSION_STRENGTH: 0.00225,
      REPULSION_RANGE: 1.4,
      BLOB_ATTRACTION: 0.0000225,
      ATTRACTION_RANGE: 0.28,
      CENTER_ATTRACTION: 0,
      BOUNDARY_MARGIN: 0.22,
      CURSOR_REPULSION: 0.00011,
      CURSOR_RADIUS: 0.3
    };

    // 2 large cores, 3 medium, 3 small satellites
    const BLOB_SIZES = [
      0.12, 0.11,
      0.075, 0.065, 0.055,
      0.04, 0.035, 0.03
    ];

    class Blob {
      constructor(index, total) {
        // Start spread out but not too far
        const angle = (index / total) * Math.PI * 2 + Math.random() * 0.3;
        const r = 0.08 + Math.random() * 0.1;
        this.x = 0.5 + Math.cos(angle) * r;
        this.y = 0.5 + Math.sin(angle) * r;
        this.vx = (Math.random() - 0.5) * 0.000132;
        this.vy = (Math.random() - 0.5) * 0.000132;
        this.radius = BLOB_SIZES[index] || 0.03;
        this.baseRadius = this.radius;
        this.phase = Math.random() * Math.PI * 2;
      }
    }

    // Tiny free-floating particles with independent physics
    const PARTICLE_CONFIG = {
      COUNT: 4,
      RADIUS: 0.024,
      DAMPING: 0.992,
      PERTURBATION: 0.00012,
      BOUNDARY_MARGIN: 0.08
    };

    class Particle {
      constructor() {
        this.x = 0.2 + Math.random() * 0.6;
        this.y = 0.2 + Math.random() * 0.6;
        this.vx = (Math.random() - 0.5) * 0.0001;
        this.vy = (Math.random() - 0.5) * 0.0001;
        this.radius = PARTICLE_CONFIG.RADIUS * (0.8 + Math.random() * 0.4);
      }

      update() {
        // Simple Brownian motion
        this.vx += (Math.random() - 0.5) * PARTICLE_CONFIG.PERTURBATION;
        this.vy += (Math.random() - 0.5) * PARTICLE_CONFIG.PERTURBATION;

        // Damping
        this.vx *= PARTICLE_CONFIG.DAMPING;
        this.vy *= PARTICLE_CONFIG.DAMPING;

        // Move
        this.x += this.vx;
        this.y += this.vy;

        // Boundary bounce
        const margin = PARTICLE_CONFIG.BOUNDARY_MARGIN;
        if (this.x < margin) { this.x = margin; this.vx *= -0.5; }
        if (this.x > 1 - margin) { this.x = 1 - margin; this.vx *= -0.5; }
        if (this.y < margin) { this.y = margin; this.vy *= -0.5; }
        if (this.y > 1 - margin) { this.y = 1 - margin; this.vy *= -0.5; }
      }
    }

    class LavaLamp {
      constructor() {
        this.canvas = document.getElementById('canvas');
        this.gl = this.canvas.getContext('webgl', { alpha: true, premultipliedAlpha: false }) ||
                  this.canvas.getContext('experimental-webgl', { alpha: true, premultipliedAlpha: false });

        // Particle overlay canvas (2D)
        this.particleCanvas = document.getElementById('canvas-particles');
        this.particleCtx = this.particleCanvas.getContext('2d');

        // Reference to background-colored text for masking
        this.textBg = document.getElementById('text-bg');

        if (!this.gl) {
          document.getElementById('fallback').style.display = 'block';
          this.canvas.style.display = 'none';
          return;
        }

        this.blobs = [];
        for (let i = 0; i < CONFIG.BLOB_COUNT; i++) {
          this.blobs.push(new Blob(i, CONFIG.BLOB_COUNT));
        }

        this.particles = [];
        for (let i = 0; i < PARTICLE_CONFIG.COUNT; i++) {
          this.particles.push(new Particle());
        }

        this.cursor = { x: -1, y: -1, active: false };
        this.time = 0;
        this.frameCount = 0;

        this.setupGL();
        this.setupEvents();
        this.resize();
        this.animate();
      }

      setupGL() {
        const gl = this.gl;

        // Enable blending for transparency
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

        const vertexShaderSource = document.getElementById('vertex-shader').textContent;
        const fragmentShaderSource = document.getElementById('fragment-shader').textContent;

        const vertexShader = this.compileShader(gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = this.compileShader(gl.FRAGMENT_SHADER, fragmentShaderSource);

        this.program = gl.createProgram();
        gl.attachShader(this.program, vertexShader);
        gl.attachShader(this.program, fragmentShader);
        gl.linkProgram(this.program);

        if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
          console.error('Program link error:', gl.getProgramInfoLog(this.program));
          return;
        }

        gl.useProgram(this.program);

        const vertices = new Float32Array([
          -1, -1,
           1, -1,
          -1,  1,
          -1,  1,
           1, -1,
           1,  1
        ]);

        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

        const positionLocation = gl.getAttribLocation(this.program, 'a_position');
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

        this.uniforms = {
          resolution: gl.getUniformLocation(this.program, 'u_resolution'),
          blobs: gl.getUniformLocation(this.program, 'u_blobs'),
          radii: gl.getUniformLocation(this.program, 'u_radii'),
          blobCount: gl.getUniformLocation(this.program, 'u_blobCount')
        };
      }

      compileShader(type, source) {
        const gl = this.gl;
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error('Shader compile error:', gl.getShaderInfoLog(shader));
          return null;
        }

        return shader;
      }

      setupEvents() {
        window.addEventListener('resize', () => this.resize());

        this.canvas.addEventListener('mousemove', (e) => {
          const rect = this.canvas.getBoundingClientRect();
          this.cursor.x = (e.clientX - rect.left) / rect.width;
          this.cursor.y = 1 - (e.clientY - rect.top) / rect.height;
          this.cursor.active = true;
        });

        this.canvas.addEventListener('mouseleave', () => {
          this.cursor.active = false;
        });

        this.canvas.addEventListener('touchmove', (e) => {
          e.preventDefault();
          const rect = this.canvas.getBoundingClientRect();
          const touch = e.touches[0];
          this.cursor.x = (touch.clientX - rect.left) / rect.width;
          this.cursor.y = 1 - (touch.clientY - rect.top) / rect.height;
          this.cursor.active = true;
        }, { passive: false });

        this.canvas.addEventListener('touchend', () => {
          this.cursor.active = false;
        });

        this.gl.canvas.addEventListener('webglcontextlost', (e) => {
          e.preventDefault();
          cancelAnimationFrame(this.animationId);
        });

        this.gl.canvas.addEventListener('webglcontextrestored', () => {
          this.setupGL();
          this.animate();
        });
      }

      resize() {
        const dpr = Math.min(window.devicePixelRatio || 1, 2);
        const width = 450;
        const height = 410;

        this.canvas.width = width * dpr;
        this.canvas.height = height * dpr;
        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);

        // Particle canvas
        this.particleCanvas.width = width * dpr;
        this.particleCanvas.height = height * dpr;
        this.particleCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }

      updatePhysics() {
        const blobs = this.blobs;
        this.time += 0.016;

        for (let i = 0; i < blobs.length; i++) {
          const blob = blobs[i];

          // Subtle radius pulsing for organic feel
          blob.radius = blob.baseRadius * (1 + 0.08 * Math.sin(this.time * 0.4 + blob.phase));

          // Random perturbation (Brownian motion)
          blob.vx += (Math.random() - 0.5) * CONFIG.PERTURBATION_STRENGTH;
          blob.vy += (Math.random() - 0.5) * CONFIG.PERTURBATION_STRENGTH;

          // Center attraction
          const cx = 0.5 - blob.x;
          const cy = 0.5 - blob.y;
          blob.vx += cx * CONFIG.CENTER_ATTRACTION;
          blob.vy += cy * CONFIG.CENTER_ATTRACTION;

          // Blob-to-blob interactions
          for (let j = i + 1; j < blobs.length; j++) {
            const other = blobs[j];
            const dx = blob.x - other.x;
            const dy = blob.y - other.y;
            const dist2 = dx * dx + dy * dy;
            const dist = Math.sqrt(dist2);
            const combinedRadius = blob.radius + other.radius;
            const repulsionDist = combinedRadius * CONFIG.REPULSION_RANGE;

            if (dist > 0.001) {
              let fx = 0, fy = 0;

              // Strong repulsion when close - keeps blobs from permanently merging
              if (dist < repulsionDist) {
                const overlap = (repulsionDist - dist) / repulsionDist;
                const force = CONFIG.REPULSION_STRENGTH * overlap * overlap;
                fx = (dx / dist) * force;
                fy = (dy / dist) * force;
              }

              // Weak attraction at longer range - brings blobs together temporarily
              if (dist > combinedRadius * 0.5 && dist < CONFIG.ATTRACTION_RANGE) {
                const attractStrength = CONFIG.BLOB_ATTRACTION * (1 - dist / CONFIG.ATTRACTION_RANGE);
                fx -= (dx / dist) * attractStrength;
                fy -= (dy / dist) * attractStrength;
              }

              blob.vx += fx;
              blob.vy += fy;
              other.vx -= fx;
              other.vy -= fy;
            }
          }

          // Cursor repulsion
          if (this.cursor.active) {
            const dx = blob.x - this.cursor.x;
            const dy = blob.y - this.cursor.y;
            const dist2 = dx * dx + dy * dy;

            if (dist2 < CONFIG.CURSOR_RADIUS * CONFIG.CURSOR_RADIUS && dist2 > 0.0001) {
              const dist = Math.sqrt(dist2);
              const force = CONFIG.CURSOR_REPULSION / dist2;
              blob.vx += dx * force;
              blob.vy += dy * force;
            }
          }

          // Viscous damping
          blob.vx *= CONFIG.DAMPING;
          blob.vy *= CONFIG.DAMPING;

          // Integrate position
          blob.x += blob.vx;
          blob.y += blob.vy;

          // Boundary containment (soft bounce)
          const margin = CONFIG.BOUNDARY_MARGIN;
          if (blob.x < margin) {
            blob.x = margin;
            blob.vx = Math.abs(blob.vx) * 0.5;
          } else if (blob.x > 1 - margin) {
            blob.x = 1 - margin;
            blob.vx = -Math.abs(blob.vx) * 0.5;
          }

          if (blob.y < margin) {
            blob.y = margin;
            blob.vy = Math.abs(blob.vy) * 0.5;
          } else if (blob.y > 1 - margin) {
            blob.y = 1 - margin;
            blob.vy = -Math.abs(blob.vy) * 0.5;
          }
        }

        // Update particles (independent physics)
        for (const particle of this.particles) {
          particle.update();
        }
      }

      render() {
        const gl = this.gl;

        // Clear with transparent background
        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.uniform2f(this.uniforms.resolution, this.canvas.width, this.canvas.height);
        gl.uniform1i(this.uniforms.blobCount, this.blobs.length);

        const positions = [];
        const radii = [];

        for (const blob of this.blobs) {
          positions.push(blob.x, blob.y);
          radii.push(blob.radius);
        }

        gl.uniform2fv(this.uniforms.blobs, new Float32Array(positions));
        gl.uniform1fv(this.uniforms.radii, new Float32Array(radii));

        gl.drawArrays(gl.TRIANGLES, 0, 6);

        // Render particles on separate 2D canvas
        this.renderParticles();

        // Update mask for background-colored text (every 2 frames for performance)
        this.frameCount++;
        if (this.frameCount % 2 === 0) {
          this.updateTextMask();
        }
      }

      renderParticles() {
        const ctx = this.particleCtx;
        const width = this.particleCanvas.width / (window.devicePixelRatio || 1);
        const height = this.particleCanvas.height / (window.devicePixelRatio || 1);

        ctx.clearRect(0, 0, width, height);
        ctx.fillStyle = '#e83525';

        for (const particle of this.particles) {
          const x = particle.x * width;
          const y = (1 - particle.y) * height;
          const r = particle.radius * Math.min(width, height);

          ctx.beginPath();
          ctx.arc(x, y, r, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      updateTextMask() {
        // Convert blob canvas to data URL and use as mask for background-colored text
        // Mask position adjusted for blob canvas offset (150px left of center)
        const dataUrl = this.canvas.toDataURL();
        this.textBg.style.webkitMaskImage = `url(${dataUrl})`;
        this.textBg.style.maskImage = `url(${dataUrl})`;
        this.textBg.style.webkitMaskSize = '450px 410px';
        this.textBg.style.maskSize = '450px 410px';
        // Position mask to align with blob canvas
        this.textBg.style.webkitMaskPosition = 'calc(50% - 265px) calc(50% - 20px)';
        this.textBg.style.maskPosition = 'calc(50% - 265px) calc(50% - 20px)';
        this.textBg.style.webkitMaskRepeat = 'no-repeat';
        this.textBg.style.maskRepeat = 'no-repeat';
      }

      animate() {
        this.updatePhysics();
        this.render();
        this.animationId = requestAnimationFrame(() => this.animate());
      }
    }

    window.addEventListener('DOMContentLoaded', () => {
      new LavaLamp();
    });
  </script>
</body>
</html>
 